
//===--- Index.swift.gyb - tests for Index types and operations -----------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Index.swift
// RUN: %S/../../utils/line-directive %t/Index.swift -- %target-build-swift %t/Index.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/Index.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest
import StdlibCollectionUnittest


var Index = TestSuite("Index")

% from gyb_stdlib_support import collectionForTraversal

% # RandomAccess does not add any new behaviors to Bidirectional
% # so we are left with just 2 traversals for the following tests
% for Traversal in ['Forward', 'Bidirectional']:
%   TraversalCollection = collectionForTraversal(Traversal)

Index.test("${TraversalCollection}/distance(to:)/dispatch") {
  let c = ${TraversalCollection}Log.dispatchTester(Array(0..<10))
  _ = c.distance(from: 0, to: 10)
  expectCustomizable(c, c.log.distance)
}

Index.test("${TraversalCollection}/index(_:offsetBy:)/dispatch") {
  let c = ${TraversalCollection}Log.dispatchTester(Array(0..<10))
  _ = c.index(c.startIndex, offsetBy: 10)
  expectCustomizable(c, c.log.advance)
}

Index.test("${TraversalCollection}/index(_:offsetBy:limitedBy:)/dispatch") {
  let c = ${TraversalCollection}Log.dispatchTester(Array(0..<10))
  _ = c.index(c.startIndex, offsetBy: 10, limitedBy: 5)
  expectCustomizable(c, c.log.advanceLimit)
}

% end

% for Traversal in ['Forward', 'Bidirectional', 'RandomAccess']:
%   Collection = collectionForTraversal(Traversal).replace('Collection', '')
%   for Base in ['Minimal', 'Defaulted']:
%     Kind = '{}{}'.format(Base, Collection)

Index.test("${Kind}Collection/distance(from:to:)/semantics") {
  let c = ${Kind}Collection(elements: Array(0..<20))
  for test in distanceFromToTests {
    let d = c.distance(
      from: c.nthIndex(test.startOffset), to: c.nthIndex(test.endOffset))
    expectEqual(
      test.expectedDistance, d, stackTrace: SourceLocStack().with(test.loc))
  }
}

Index.test("${Kind}Collection/index(_:stepsFrom: n)/semantics") {
  for test in indexStepsFromTests.filter(
    {$0.limit == nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(elements: Array(0..<10))

    let new = c.index(c.nthIndex(test.startOffset), offsetBy: test.distance)
    // Since the `nthIndex(offset:)` method performs the same operation
    // (i.e. advances `c.startIndex` by `test.distance`, it would be
    // silly to compare index values. Luckily the underlying collection
    // contains exactly index offsets.
    expectEqual(test.expectedOffset!, c[new],
      stackTrace: SourceLocStack().with(test.loc))
  }
}

%     if Traversal == 'Forward':
Index.test("${Kind}Collection/index(_:stepsFrom: -n)/semantics") {
  for test in indexStepsFromTests.filter({$0.limit == nil && $0.distance < 0}) {
    let c = ${Kind}Collection(elements: Array(0..<10))
    let start = c.nthIndex(test.startOffset)
    expectCrashLater()
    _ = c.index(start, offsetBy: test.distance)
  }
}
%     end

%     if Traversal == 'Forward':
Index.test("${Kind}Collection/advance(by: -n, limitedBy:)/semantics") {
  for test in indexStepsFromTests.filter({$0.limit != nil && $0.distance < 0}) {
    let c = ${Kind}Collection(elements: Array(0..<10))
    let limit = c.nthIndex(test.limit.unsafelyUnwrapped)
    let start = c.nthIndex(test.startOffset)
    expectCrashLater()
    _ = c.index(start, offsetBy: test.distance, limitedBy: limit)
  }
}
%     end

Index.test("${Kind}Collection/advance(by: n, limitedBy:)/semantics") {
  for test in indexStepsFromTests.filter(
    {$0.limit != nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(elements: Array(0..<20))
    let limit = c.nthIndex(test.limit.unsafelyUnwrapped)

%     if Traversal == 'Forward':

    if test.distance < 0 {
      expectCrashLater()
    }

%     end

    let new = c.index(
      c.nthIndex(test.startOffset),
      offsetBy: test.distance,
      limitedBy: limit)
    if test.expectedOffset == nil {
      expectEmpty(new)
    } else {
      expectEqual(c.nthIndex(test.expectedOffset!), new!,
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

// Check that a random access collection doesn't call into O(n) predecessor
// calls when it has a more efficient implementation.

%     if Traversal == 'RandomAccess' and Base == 'Defaulted':

Index.test(
  "${Kind}Collection/index(_:offsetBy:)/"
  + "avoidsSuccessorAndPredecessor/dispatch"
) {
  for test in indexStepsFromTests.filter(
    {$0.limit == nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(Array(0..<10))

    let i = c.nthIndex(test.startOffset)
    let result  = c.index(i, offsetBy: test.distance)
    expectEqual(0, c.timesSuccessorCalled.value)
    expectEqual(0, c.timesPredecessorCalled.value)
  }
}

#if false // FIXME: swift-3-indexing-model. implementation missing
Index.test(
  "${Kind}Index/index(_:offsetBy:limitedBy:)/"
  + "avoidsSuccessorAndPredecessor/dispatch"
) {
  for test in indexStepsFromTests.filter(
    {$0.limit != nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(Array(0..<10))

    let i = c.nthIndex(test.startOffset)
    let limit = c.nthIndex(test.limit.unsafelyUnwrapped)
    _ = c.index(i, offsetBy: test.distance, limitedBy: limit)
    expectEqual(0, c.timesSuccessorCalled.value)
    expectEqual(0, c.timesPredecessorCalled.value)
  }
}
#endif

%     end
%   end
% end

runAllTests()
